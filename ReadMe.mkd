Java Orignal designed and released in 1995. Object Oriented Programming Language. 

The Java Virtual Machine (JVM): 

The JVM is responsible for taking in Java bytecode and executing the instructions of a program. 

The JVM made Java popular as it allows a Java program to run the same way on different OS and Platforms. 

This is why Java has the slogan WORA (write once, run anywhere).

Cycle of a Java Program: 

Code is written in a .java file. When run this is converted to bytecode (a machine language). The bytecode is sent to the JVM where it is analysed and then executed. The JVM terminates once it executes the final instruction. 

Note: The Java compiler turns the code to bytecode and the JVM then interprets. The JVM is not a compiler. 

!!!!!!
Syntax

Google has compiled a guide: https://google.github.io/styleguide/javaguide.html to find something specific. 

Naming Conventions: 

Java uses Camel case for most names. 

Class and Interface names use PascalCase i.e. LinkedList. 

Constants use SNAKE_CASE i.e. VALUE_OF_PI.

Brackets and Parentheses: 

Brackets must be used for all method and class declarations, conditionals and loops with multiple lines. 

They can be omited for single line but better for readability. 

if (true) {
    return false; 
}

Indentations and Spacing: 

Amount of indentation and white space does not affect compiling or runing. 

However, spacing should be added for readability. 


!!!!!
Downloading Java:

There are many IDE's that can run Java but it can also be run from the command line. 

Your computer most likely has the Java Runtime Environment to run programs. It compiles Java Bute Code from generic files to be run specificaly on your type of computer. 

As a Developer you need the Java Development Kit (JDK). Allowing you to access classes and interfaces of teh core Jaa language. 

There are a variety of versions of JDK at: https://www.oracle.com/java/technologies/downloads/. However most development occurs in standard edition (SE). 

!!!!
Compiling Java:

Before running a program in the command line it muse be compiled. Navigate to where the file is you want to run and use e.g. 

``` 
javac MyClass.java
```
This creates the .class file that can be executed. If there are any bugs they will be flagged at this point and the file will not be created. 

!!!
Running Java 

Once Executable you can run it using: 

```
java MyClass 
```

(omit the .java or .class suffix)

Complete example:  !!! <---- Very Important: 

file: HelloWorld.java contains: 

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}

CLI: 

javac HelloWorld.java 

Output: HelloWorld.class created

java HelloWorld

output: Hello world!


Main Method Params !!! <---- Very Important: 

Every main method contains the params String[] args. This means that args is an array of strings. We can use these in our class if we wish. 

All arguments passed in the cli will be treated as strings and so numbers need to be parsed.

Some files will have a main method and others will not. When we use the java command we are specifying which java class that we should look for the main method in. 

Complete example:  !!! <---- Very Important: 

file: HelloWorld.java contains: 

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello world, my name is " + args[0] + "!");
  }
}

CLI: 

javac HelloWorld.java 

Output: HelloWorld.class created

java HelloWorld Batman

output: Hello world, my name is Batman!


!!!!
Hello World and Class Structure

Class Structure: 
Object-oriented programming consisting of classes and methods. Java only has methods and no functions. 

Classes: 
Public - Can be accessed from any other class or method in the environment. 

Private- restricts the visibiliy of a class to within the parent class e.g. 

public class MyClass {
    private int privateVariable;  // Only accessible within MyClass

    private void privateMethod() {
        // Only callable within MyClass
    }
}

i.e. in Java the top level cannot be private otherwise it could never be called. 

Protected- Middle ground whereby the protected member is accesibile within the ame package and in subclasses even in different packages. 

e.g. 
public class BaseClass {
    protected void protectedMethod() {
        // Accessible in subclasses and in the same package
    }
}

public class DerivedClass extends BaseClass {
    void accessMethod() {
        protectedMethod();  // Allowed access
    }
}

Methods: 
Every Java program must have a method called main(). This main method holds all of the instructions for the program (the master method that controls the whole program). As noted this main method always has String[] args. 

e.g.
/home/spencer/LearnJava/CodingExamples/HelloWorld/HelloWorld.java

!!! 
Print Statements 

Print Statements: 
system.out.print("Some Text");
prints on the line. If you system.out.print they will print next to each other: 
system.out.print("Some Text");
system.out.print("Some Text");
Output: 
Some TextSome Text

system.out.println("Some Text");
prints and then creates a new line for the next piece of text. 
system.out.println("Some Text");
system.out.print("Some Text");
Output: 
Some Text
Some Text

!!!
Comments

inline Comments: 
// Here is a comment

Block comments: 
/* Here is some text that could be 2 lines */ 

!!!
Variables and Types

Declaring: 
When declaring a variable the dataType must be declared. 

Syntax <- important-> 
dataType variableName = value;

dataType variableName;

dataType variableName;

Data Types: 
int- 
Whole numbers 
*between -2147483648 and 2147483647
e.g. int moonLanding = 1969;

double- 
Decimals
*4.9E-324 and 1.7976931348623157E+308:
e.g. double PI = 3.14;

boolean- 
true or false
e.g. boolean isRaining = true;

char 
single character
e.g. char firstLetter = 'a';


Manipulating Number-Based Variables: 
Mathmatical symbols are valid syntax as in JavaScript i.e. 

int num = 3 + 2; // num now equals 5
num = num - 1; // num now equals 4

you can increment and decrement: 
++ -- 

and compound: 
+= 

!!!!
Strings

strings are a reference data type as they are objects from the String class. 
e.g. String greetings = "Greetings, earthlings!"

!!!!
Conditional Statements and Comparison Operators

if: 

if (expression) {
  // Code to run if expression is true
}

else: 

if (expression) {
  // Code to run if expression is true
} else {
  // Code to run if expression is false
}

if- else: 

if (expression) {
  // Code to run if expression is true
} else if (expression) {
  // Code to run if previous expression is false and current condition is true
} else {
  // Code to run if all previous expressions are false
}

Comparison Operators: 
e.g.
&& - and 
|| - or 
! - not 
== - equal to 
!= - not equal to 
etc. 

!!!
Loops

While: 

while (num < 20) {
  num = num + 1;
}

do-while: 

do {
 System.out.println("2 is equal to 4!");
} while (2 == 4);

for: 

for (int i = 0; i <= 10; i++) {
  System.out.println(i);
}

for each: 

for (String s : myArray) {
  // Do something
}
(each element in the array is a string, s holds the value of the element in the loop, myArray is what is being iterated)

break: 
Used to exit a loop- 

for (int i = 0; i < 10; i++) {
  System.out.println(i);
  if (i == 4) {
    break;
  }
}

continue: 
continue will skip an interation if true and go to the next iteration without exiting the loop altogether. 

for (int i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 == 0) {
    continue;
  }
  System.out.println(numbers[i]);
}

!!!
User-Defined Methods

Anatomy of a Method: 

public static void exampleMethod() {
  System.out.println("Hello Method!");
}

public method- can be accesed by any part of the program. 

static method - can be called throughout a program without creating an object of the class 

void method- does not return a value 

empty brackets- this method takes no params

(A method is called with exampleMethod() )

!!!
Params and Arguments: 

Parameters are the holders that are put in place when declaring the method i.e. 
public static void exampleMethod(String greeting, String name) {
  System.out.println(greeting + " " + name);
}

Arguments are what are passed when it is invoked: 
public static void main(String[] args) {
  exampleMethod("Greetings", "Earthling");
}

!!! 
Returning: 

if the function is returning then the data type to be returned needs to be declared 

e.g. 
public static int findProduct(int num1, int num2) {
  return num1 * num2;
}
public static void main(String[] args) {
  int product = findProduct(3,4);
  System.out.println(product); // Prints: 12
}

String Methods: 

.length() - length

.concat() - concatenates - adds to end of another string e.g. name.concat("cademy")

.equals() - checks equality as we cannot use == with strings. e.g. flavor1.equals("Mango")

.indexOf() - index of the first occurence of a char. e.g. letters.indexOf("C") 

.charAt() - returns char at the index. e.g. currency.charAt(2)

.substring() outputs the string split. One arg will cut from that index to end. Two is the beginning and then end index. e.g. line.substring(7, 24)

.toUpperCase() / .toLowerCase() - Makes all chars upper or lower case. 


Code Challenge: 

1. Leftover Funds
We start with 0 burritos, and a quantity of money. Update the code to return false or true as to whether there is left over funds. 

CodingExamples/BurritoCalculator/BurritoCalculator.java

2. Burritos Sold
Update the function to work out how many Burritos sold. 

CodingExamples/BurritoCalculator2/BurritoCalculator2.java

Code Challenge: 

1. Create new string with chars reversed
CodingExamples/Reverse/Reverse.java 

2. Find if one or more substrings has a problem
CodingExamples/Replace/Replace.java

!!!
Arrays

Declaring an empty array: 
(this declares and tells the machine that there will be a an array with this name created in the future but currently this does not point to an actual space in memory! - see create empty array)

int[] lottoNumbers;
String[] clothingItems;

Declaring a populated array:

int[] lottoNumbers = {12, 29, 4, 38, 3};
String[] clothingItems = {"Huipil", "Beanie", "Kimono", "Sari"};

Accessing an element by index: 
(0 indexed)

String[] clothingItems = {"Huipil", "Beanie", "Kimono", "Sari"};
clothingItems[2];

Changing an Elements Value: 

arrayName[index] = newValue;


Create an Empty array: 
(this initialises the array and populates it with empty null values)

dataType[] emptyArrayName = new dataType[number of elements in array];

.length: 
provides the number of elements

e.g:
lottoNumbers.length

for loop: 

e.g.
for (int i = 0; i < lottoNumbers.length; i++) {
  // action
}

for-each loop: 

e.g
int[] lottoNumbers = {12, 29, 4, 38, 3};
for (int num: lottoNumbers) {
  System.out.println(num);
}

Example: 
CodingExamples/ArraysExample/ArraysExample.java

!!!
2D Arrays

A two dimensional array is an array that stores arrays of the same data type

i.e. 

[["a","b","c"],["d","e","f"],["g","h","i"]]

Declaring a 2D array: 

dataType[][] variableName; 

e.g.
int[][] nums;


Declaring and populating:

int[][] nums = {{10, 9, 8}, {7, 6, 5}, {4, 3, 2}}; 

Accessing an element in a 2D array: 

arrayName[firstIndex][secondIndex]

e.g. 

int[][] nums = {{10, 9, 8}, {7, 6, 5}, {4, 3, 2}}; 
// Within the first array, access the second element:
System.out.println(nums[0][1]); // Prints: 9

Updating a value: 

this is the same as a standard array using the assignment operator

e.g.
char[][] letters = {{'A', 'a'}, {'B', 'x'}, {'C', 'c'}};

// Update the value:
letters[1][1] = 'b';
System.out.println(letters[1][1]); // Prints: b

creating an empty 2D array: 
As with a normal array the length of the array needs to be qualified. 



e.g
int[][] intArray = new int[2][3];

!!! 
Row- Major Order

Traversal path that moves horizontally through each row starting at the first to the last i.e. 

[[1, 2, 3],
[4, 5, 6],
[7, 8, 9],
[10, 11, 12]]

Can be done with an outer and inner loop: 
Outer loop iterate the length of the array counted the nested arrays. 
Inner loop counts the elements in the nested array. 
Once a nested array completed it will move on to the next iteration of the outer loop which is the next array. 

for (int i = 0; i < letters.length; i++){
  for (int j = 0; j < letters[0].length; j++){
    System.out.print(letters[i][j]);
  }
}

Column- Row Order

Traversal path that moves vertically down each column starting with the first to last. 
i.e. 

[[1,5,9,13],
[2,6,10,14],
[3,7,11,15],
[4,8,12,16]]

nested for loop: 
Outer loop iterate the length of a nested array
inner loop iterate the number of nested arrays. 
Outer loop targets the column whilst inner loop targets the row. 

e.g. 
for (int i = 0; i < letters[0].length; i++){
  for (int j = 0; j < letters.length; j++){
    System.out.print(letters[j][i]);
  }
}

Arrays.sort()  - to sort arrays alphanumerically etc. 

Array Lists have mutable size (you can add and remove elements freely). 

Challenges: 

1. Total cost for Groceries
CodingExamples/GroceryList/GroceryList.java

2.  Most Expensive Grocery Item
CodingExamples/GroceryList2/GroceryList2.java

3. Lengthy Groceries
CodingExamples/LengthyGroceries/LengthyGroceries.java

4. Special Item 
/home/spencer/LearnJava/CodingExamples/HasSpecialItem/HasSpecialItem.java

5. Alphabetical Items
/home/spencer/LearnJava/CodingExamples/isAlphabetised/isAlphabetized.java

6. Duplicate Items
/home/spencer/LearnJava/CodingExamples/HasDuplicates/HasDuplicates.java

7. Reverse the array of Groceries
/home/spencer/LearnJava/CodingExamples/ReverseGroceries/ReverseGroceries.java

8. 
/home/spencer/LearnJava/CodingExamples/RotateArray/RotateArray.java

## Code Challenge: Traversing 2D Arrays

Traversing a 1D Array: 
/home/spencer/LearnJava/CodingExamples/KoalaCounting/KoalaCounting.java

Traversing a 2D array: 

Add up the numbers in the nested 2D array
/home/spencer/LearnJava/CodingExamples/GetTotal/GetTotal.java

Searching for a Value in a 2D array: 
searching through 2D array to find values that meet a certain condition- 
/home/spencer/LearnJava/CodingExamples/FindValueGreater/FindValueGreater.java

Find the collumn with Largest Value: 
search array by column rather than row to find largest column array- 
/home/spencer/LearnJava/CodingExamples/LargestValue/LargestValue.java

---

# Classes and Constructors 

1. General Structure
2. Access Modifiers 
3. Constructors

## Classes 

A class is the set of instructions that describe how an instance can behave and what information it contains. Java has predefined classes such as System but we can create our own. 

**Structure of a Class**

  public class Car {

    public static void main(String[] args) {

    }

  }
  
**Access Modifiers**: 
  Public is an access level modifier that allows other classes to interact with this class. There are four types of access modifiers

Modifier    | Class | Package | Child Class | Global |
Public      |   X   |    X    |       X     |   X    | 
Protected   |   X   |    X    |       X     |   -    |
no modifier |   X   |    X    |       -     |   -    |
private     |   X   |    -    |       -     |   -    |

**Constructors**
In order to create an object (instance of a class) we need a constructor method. 

  public class Car {
    // Constructor method:
    public Car() {
      // Instructions for creating a Car instance
    }  

    public static void main(String[] args) {

    }
  }

To create an instance we need to call/invoke the constructor within main(). The following example assigns a Car instnace to the variable ferrari. 

  public class Car {

    public Car() {
      // Instructions for creating a Car instance
    }
  
    public static void main(String[] args) {
      // Invoke the constructor:
      Car ferrari = new Car(); 
    }
  }

In this example the variable ferrari is declared as *reference data type*. The value of ferrari is a reference to an instance in memory. 

The **new** keyword is essential as it indicates a new instance of car(). Omitting it causes an error. 

The value of ferrari is currently its memory address i.e. : Car@76ed5528

**Invoking the Constructor** 

When we create a new instance we invoke the constructor. Any code inside the constructor will be executed- 

Example:

  public class Car {

    public Car() {
      System.out.println("I'm a constructor!");
    }
  
    public static void main(String[] args) {
      // Invoke the constructor:
      Car ferrari = new Car(); // Prints: I'm a constructor! 
    }
  }

## Object State and Behaviour

In Java an object is a specific instance of a class.

- Creating an object
- Object state 
- Object behaviour 
- the .toString() method

### Creating an Object 

Objects and classes are closely related. Classes define the attributes and behaviours of an object. 

To create an object declare a variable in the main() method with the class name as the data type and set the value to a call to the class constructor. 

The class name is used as the data type because objects have reference data types (the value of the variable is a reference to an instance memory address)



Example: 
  class Cat {
    // Class constructor:
    public Cat(){
      // Instructions for creating an instance of Cat goes here:
    }

    public static void main(String[] args) {
      // Create a Cat object by calling the constructor:
      Cat myCat = new Cat();
    }
  }


      Cat myCat = new Cat();

*Cat* - is the data type, it is a reference to the class Cat 

*myCat* - is what we are naming the variable which is a instance of Cat. 

*new* - must be used to invoke a new instance

*Cat()* - is invoking the Cat() method within the class Cat. 

### Object State

State refers to the attributes of an object.

State can be defined using instance variable, or instance fields, which are placed inside of a class. 

**Creating Instance Fields**

To create an instance field, initialise variables inside the class container

Example: 
  class Cat {
    // instance fields:
    String noise = "meow";
    int numLives = 9;
    
    public Cat(){
      // Instructions for creating an instance of Cat goes here:
    }

    public static void main(String[] args) {
      Cat myCat = new Cat();
    }
  }

To access an objects instance fields, append the dot operator followed by the instance fields name to the name of the object: 

Example: 
  Cat myCat = new Cat();
  // Access instance variable of an object:
  System.out.println(myCat.noise); // Prints: meow

### Defining State with Parameters

To create dynamic objects, parameters can be added to the class constructor. Instance variables can then be assigned the parameter values. 

Example: 
  class Cat {
    // Instance fields:
    String noise;
    int numLives = 9;
    
    // Constructor takes in one String parameter
    public Cat(String animalNoise){
      // Assign instance variable to parameter value:
      noise = animalNoise;
    }

    public static void main(String[] args) {
      // Send argument to constructor when creating an object:
      Cat firstCat = new Cat("mew"); 
      // Send argument to constructor when creating another object:
      Cat secondCat = new Cat( "mow");
      
      System.out.println(firstCat.noise); // Prints: mew
      System.out.println(secondCat.noise); // Prints: mow
    }
  }

#### THIS 

**The this keyword**

the *this* keyword is used to reference the current object. 

Example: 
  class Cat {
    String noise;
    int numLives = 9;
    
    // Parameter has same name as the instance variable
    public Cat(String noise){
      // Assign instance variable to parameter value:
      this.noise = noise;
    }
  }

### Object Behavior 

**Non-Static Methods** 

We can give objects functions (behaviours) by using non-static methods. This is a "method" (function) that belongs to the class. These are declared without the static keyword 

Example: 
  class Cat {
    String noise;
    int numLives = 9;
  
    // Non-static method:
    public void speak() {
      System.out.println(noise);
    }
    
    public Cat(String animalNoise){
      noise = animalNoise;
    }

    public static void main(String[] args) {
      Cat myCat = new Cat("mew");
    }
  }

**Invoking non-static method** 

A non static method can be invoked following a . with the method name 

Example: 
  Cat myCat = new Cat("mew");
  // Invoke non-static method on an object:
  myCat.speak(); // Prints: mew


#### .toString()

the toString() method can be added to a class in order to create a unique output when printing an object. The original toString() exists in the Object class but is often overridden for a unique output

Example: 
  class Cat {
    String noise;
    int numLives = 9;
  
    public String toString() {
      return "The cat with " + numLives + " lives says " + noise;
    }
    
    public Cat(String animalNoise){
      noise = animalNoise;
    }

    public static void main(String[] args) {
      Cat myCat = new Cat("mew");
      System.out.println(myCat); // Prints: The cat with 9 lives says mew
    }
  }

## Getter and Setter Methods

When making a class we often make the variables *private*. We might want other classes to access them but not to know the exact variable name. 

### Accessor Methods (Getter)

To give other classes access to private instance variables we would write an accessor method

Example: 
  public class Dog {
    private String name;
      
    // Other methods and constructors

    public String getName() {
      return name;
    }

    public static void main(String[] args) {
      Dog myDog = new Dog("Lassie");
      System.out.println(myDog.getName()); // Prints: Lassie
    }
  }

Name is a private variable i.e. cannot be accessed outside the class. However getName() is provided in order to retrieve (or *get*) the value of this variable. 

### Mutator Methods (Setter)

These methods allow other classes to reset the value stored in private instance variable 

Example: 
  public class Dog {
    private String name;
      
    // Other methods and constructors

    public void setName(String newName) {
      name = newName;
    }

    public static void main(String[] args){
      Dog myDog = new Dog("Cujo");
      myDog.setName("Lassie");
    }
  }

Mutator methods are often *void* i.e. have no return value they just reset the value. Similarly often only have one parameter that is the thing they are designed to mutate/Set. 

# Scope

scope defines where a variable or method is accesible from in a program 

- Types of variable scope 
- Access modifiers

**Variable Scope** 

1. Class Level Scope 
2. Method Level Scope 
3. Block Scope

## Class Level Scope

Any variable declared within a class is accesible by all methods in that class. Depending on access modifier (public/private) can sometimes be accessed outside the class. 

Example:
  public class Car {
    public String color;
    private int speed;

    public Car(String color, int speed) {
      // Variables color and speed accessible here
    }

    public void drive(boolean fourWheel) {
      // Variables color and speed accessible here
    }
  }

  public class BuyCar {
    public static void main(String[]args) {
      Car carObject = new Car("blue", 70);
      // Can access the public variable, color, in this class
      String carColor = carObject.color;
      // Can’t access the private variable, speed, in this class
      // int carSpeed = carObject.speed -- This results in an error, can’t access speed here
    }
  }

## Method Level Scope

Anything declared in the method is not accesible outside that method. 

Example: 
  public class Car {
    public String color;
    private int speed;

    public void drive(boolean fourWheel) {
      String tires = "wide";
      // fourWheel and tires are only accessible here
      // fourWheel and tires are destroyed after drive() finishes
    }

    public void paint(String newColor, String oldColor) {
      // newColor and oldColor are only accessible here
      // newColor and oldColor are destroyed after paint() finishes
    }
  }

  public class PaintCar {
    // The only variable from Car accessible in this class is color
    // None of the variables declared in Car methods are accessible in this class
  }

## Block Scope

Any variable declared in a for loop not accesible outside of that loop/block

Example: 
  public class Car {
    public void changeTires() {
      int numTires = 4;
      int changedTires = 0;
      for (i = 0; i < numTires; i++) {
        changedTires += 1;
      }
      // numTires and changedTires are accessible here, i is not
    }
  }

## Access Modifiers 

there are four access modifiers that restrict the accesibility of the method or variable. They are only used within classes not within methods 

1. Private
2. Default 
3. Protected
4. Public

### Private

*Most* restrictive. limits access to methods and variables to the **class** that they are declared in. Chosen when methods or variables not needed outside the class. 

### Default (no modifier)

Allows access only from within the current **package**. If not specified the method or variable will take this on. 

### Protected

Allows access to method/variable from within the current package *unless* it is accessed through a child class outside the package. 

### Public

The *least* restrictive modifier. Allows acces to class/method/variable from the class and outside the class. 

### Example: 
  public class MinHeap {
    public ArrayList<Integer> heap;
    public int size;

    public MinHeap() {
      // Body of constructor
    }
    public void add(int value) {
      heap.add(value);
      size++;
      bubbleUp();
    }
    private void bubbleUp() {
      // Body of .bubbleUp() method
    }
  }

  public class TrackAges {
    public static void main(String[]args) {
      MinHeap ages = new MinHeap();
      // Can call public MinHeap .add() method here:
      ages.add(42);
      ages.add(15);
      ages.add(27);
      // Can’t call private MinHeap .bubbleUp() method here
      // Don’t need to because .add() calls .bubbleUp()!  
    }
  }

# Inheritance

- Superclasses and Subclasses 
- the super() method
- access modifiers

## Superclasses and Subclasses (extends)


Superclasses- 
The class that another class inherits from. 

Subclasses- 
The class that inherits qualities from another class. 

An object/instance of a subclass inherits all the available instance variables and methods in the superclass. 

In order to create this relationship the Subclass has to **extends** the Superclass- 

Example: 
  class Shape {
    Shape() {
      System.out.println("I am a shape!");
    }
  }
  // Make Triangle a subclass of Shape:
  class Triangle extends Shape {
    Triangle() {
      System.out.print("I am a triangle!");
    }
    public static void main(String[] argos) {
      Shape sq = new Shape(); // Prints: I am a shape!
      Triangle tri = new Triangle();
      /* Prints:
      I am a shape!
      I am a triangle!
      */
    }
  }

### The super() Method

When an instance of a subclass is created the subclass constructor will automatically invoke the superclass constructor. 

The *super()* method allows us to control what arguments are sent to the superclass constructor when creating an object of the subclass. 

To invoke the *super()* method place it in the body of the subclass constructor. 

Example: 
  class Shape {
    int numSides;
    Shape(int numSides) {
      this.numSides = numSides;
    }
  }
  
  class Triangle extends Shape {
    Triangle() {
      // Use super() to call the Shape constructor:
      super(3);
    }

    public static void main(String[] args) {
      Shape sq = new Shape(4);
      Triangle tri = new Triangle();
      System.out.println(sq.numSides); // Prints: 4
      System.out.println(tri.numSides); // Prints: 3
    }
  }

# Polymorphism 

Allows a subclass to share information and behaviour of its superclass while also incorporating its own functionality. 

- Using Methods of a superclass 
- Overriding superclass methods
- Using a subclass in place of its superclass 

## Using Methods of a Superclass

The methods of the Superclass are available to the subclass with .method()

Example: 
  // Parent class:
  class Bird {
    public Bird() {
      // Instructions for creating a Bird go here:
    }

    public void move() {
      System.out.println("The bird flies away");
    }
  }
  
  // Child class:
  class Flamingo extends Bird {
    public Flamingo() {
      // Instructions for creating a Flamingo go here:
    }
  
    public static void main(String[] args) {
      Flamingo myFlamingo = new Flamingo();
      myFlamingo.move(); // The bird flies away
    }
  }

## Overriding Superclass Methods

If we want a subclass method to behave differently to the superclass method we can override the method. It must have the same name (signature) and also use *@Override*

Example: 
  // Parent class:
  class Bird {
    public Bird() {
      // Instructions for creating a Bird go here:
    }

    public void move() {
      System.out.println("The bird flies away");
    }
  }
  
  // Child class:
  class Penguin extends Bird {
    public Penguin() {
      // Instructions for creating a Penguin go here:
    }
    
    // Override the parent class method:
    @Override
    public void move() {
      System.out.println("The penguin waddles away");
    }
  
    public static void main(String[] args) {
      Penguin myPenguin = new Penguin();
      myPenguin.move(); // Prints: The penguin waddles away
    }
  }

## Using Subclass in place of its Superclass

Polymorphism makes it possible to send an instance of a subclass somewhere where an instance of the superclass is expected. 

**Creating an Instance** 

We can use the superclass as the reference data type when creating a new object from a subclass. 

Example: 
Superclass  = Plant 
Subclass    = Succulent 

You can create an insance with a declared type "plant" but an actual type of Succulent: 

Plant echeveria = new Succulent();

### Creating Arrays or ArrayLists 

Arrays and Array Lists can only contain values of the same type. If we declare objects as "reference type" to the superclass we can store all of the instances in one array. 

i.e. if there is a Monster superclass and subclasses Vampire, Werewolf, Zombie etc. We can create a Monster type array list. 

Example: 
Monster dracula, wolfman, evilZombie;
 
dracula = new Vampire();
wolfman = new Werewolf();
evilZombie = new Zombie();
 
Monster[] monsters = {dracula, wolfman, evilZombie};

### Sending an Object as a Parameter

If a method or constructor parameter requires an object of a superclass to be passed in when it is invoked, we can send an object of the subclass as an argument. 

If cat is a subclass of Animal we can use an instance of Cat as an argument. 

Below in Class Vet there is a method getCheckUp(). This take a type *Animal* parameter name *patient*. 

When calling the getCheckup method we can pass a instance of an Animal i.e. myCat. 

Example: 
  class Vet {
    public void Vet() {
      // Instructions for instance go here:
    }
    public void getCheckUp(Animal patient) {
      // Instructions for method go here:
    }

    public void main(String[] args) {
      // Create a Vet object
      Vet catDoctor = newVet();
      // Create an Animal object
      Animal myCat = new Cat();
      // Send Animal object as a parameter for a Vet method:
      catDoctor.getCheckUp(myCat);
    }
  }

# Project- Language Families
**Project Files** 
/home/spencer/LearnJava/LanguageFamilies

*Error*
During the project i found that i could not compile one Class that called the subclass as the subclass was not yet compiled. However, i could not compile the subclass because it relied on the other class. 

Easy fix: 
Compile both at sametime- 
javac Language.java Mayan.java 

Other Option: 
Move the main method in to a seperate class- 
public class LanguageTest {
    public static void main(String[] args) {
        Language myLang = new Language("Spencer", 100, "United Kingdom", "subject-verb-object");
        myLang.getInfo();

        Mayan myMayan = new Mayan("Kiche", 1222223090);
        myMayan.getInfo();
    }
}

# Lists

Java has built-in *List* Class

Array has a fixed size. To create mutable and dynamic store/lists we can use List classes

They allow us to:
- Store object references as elements 
- Store elements of the same type (like arrays)
- Access elements by index (like arrays)
- Add elements 
- Remove elements

## ArrayLists 

built in ArrayList Class uses dynamic array to store its elements. You can retrieve elements by their index, no size limit. 

ArrayLists (in general) more efficient than other types of lists when storing and accessing elements. 

### Declaring 

- Must be declared with type that will be stored inside angle brackets

Example: 

ArrayList<Integer> myList = new ArrayList<Integer>();

This creates a list with default initial capacity of 10. If you want to create a larger default capacity this can be declared such as 12 below 

Example: 

ArrayList<Integer> myList = new ArrayList<Integer>(12);

It can be stretched beyond this capacity even when not declared etc. 

*Can't use primitive types inside the angle brackets*
Hence Integer instead of int (Integer is an object, ArrayLists store objects. String in Java is ablso an object so can store strings)ArrayList

Available types: 
- tbc 

#### Note- You must import java.util.ArrayList at the top of the program 

### Adding to ArrayList .add()

You can add using .add() method

Example: 

ArrayList<String> months = new ArrayLIst<String>(12);
months.add("January"); 
System.out.println(months); Prints: [January]

#### Adding by Index

To add by index indicate the index you want to add to. This will add the item to that index. If an element is already at that index the new element takes it place and everything including the one being replaced is shifted over by 1. 

**You can only add an elemtn to a specified index that already exists/ or / the end of the list**
*java.lang.IndexOutOfBoundsException* 

### Retrieving a Value from an ArrayList .get()

.get(i) 

.get takes an index and retrieves that element. 

Example: 
  ArrayList<String> months = new ArrayList<String>(12);
  months.add("January");
  months.add("February");
  months.add("March");
  System.out.println(months.get(1)); // Prints: February

### Removing from an ArrayList .remove()

.remove(i)

.remove removes the index, or it can remove the first occurance of the element

Example: - index
ArrayList<String> months = new ArrayList<String>(12); 
months.add("January"); 
months.add("February"); 
months.add("March"); 
months.remove(1)
System.out.println(months); Prints: [January, March]

Example: - Occurance
ArrayList<String> months = new ArrayList<String>(12); 
months.add("January"); 
months.add("February"); 
months.add("March"); 
months.remove("February"); 
System.out.println(months); // Prints: [January, March]

## LinkedLists

- ArrayLists are better for storing and accessing data. 

- LinkedLists are more efficient for manipulating data. 
  - Doubly Linked Lists

### Declaring a LinkedList

There are no sizes associated with LinkedLists. 

Example: 
LinkedList<String> days = new LinkedList<String>(); 

#### Note- You must import java.util.LinkedList at the top of the program 

### Adding to a LinkedList .add()

Similar to ArrayList the .add(element) method allows you to append to the end of the LinkedList.

Example: 
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  System.out.println(days); // Prints: [Monday, Tuesday]


.add(i, element) adds the element to where you want the new element to go. 

Example: 
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  days.add(0, "Sunday");
  System.out.println(days); // Prints: [Sunday, Monday, Tuesday]

### Retrieving a Value from LinkedList .get()

Example: 
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  days.add(0, "Sunday");
  System.out.println(days.get(1)); // Prints: Monday

#### .getFirst() .getLast()

Both are available for LinkedList

### Remove from LinkedList .remove()

Example: - index
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  days.add(0, "Sunday");
  days.remove(1);
  System.out.println(days); // Prints: [Sunday, Tuesday]

Example: - first occurence
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  days.add(0, "Sunday");
  days.remove("Monday");
  System.out.println(days); // Prints: [Sunday, Tuesday]

Example: - First element
  LinkedList<String> days = new LinkedList<String>();
  days.add("Monday");
  days.add("Tuesday");
  days.add(0, "Sunday");
  days.remove();
  System.out.println(days); // Prints: [Monday, Tuesday]


# HashMaps

A HashMap is a built-in structure tha stores key-value pairs. Each key is a unique identifier for its associated value. 

- Creating a HashMap 
- Adding a key-Value pair
- Accessing a value 
- removing a key-value pair
- traversing a HashMap 
- additional HashMap methods

## Creatng 

*Ensure we import a Hashmap to use it* 

import java.util.HashMap 

Declaring a HashMap we state data type of key and value. We can only use reference type values: 

HashMap<String, Integer> teaSteepingTemp = newHashMap<>(); 

## Adding a Key-Value Pair .put() 

.put() is used to add key-value pairs. The method requires two arguments, 
1. The first is the key
2. The second is the associated value

Example: 
HashMap<String, Integer> teaSteepingTemp = new HashMap<>();

// Add key-value pairs to HashMap:
teaSteepingTemp.put("Oolong", 185);
teaSteepingTemp.put("Rooibos", 212);

// Output a HashMap:
System.out.println(teaSteepingTemp); // Prints: {Oolong=185, Rooibos=212}

## Accessing a Value .get()

.get() is used to retrieve an argument from the hashmap. The key is the unique identifier for the value

Example: 
int oolongTemp = teaSteepingTemp.get("Oolong");
System.out.println(oolongTemp);  // Prints: 185

## Removing Values .remove() .clear

#### .remove()
To remove a single key value pair .remove(key)

Example: 
HashMap<String, Integer> teaSteepingTemp = new HashMap<>();
teaSteepingTemp.put("Oolong", 185);
teaSteepingTemp.put("Rooibos", 212);

// Remove an item:
teaSteepingTemp.remove("Oolong");
System.out.println(teaSteepingTemp); // Prints: {Rooibos=212}

#### .clear()

.clear() removes all items from the HashMap 

Example: 
HashMap<String, Integer> teaSteepingTemp = new HashMap<>();
teaSteepingTemp.put("Oolong", 185);
teaSteepingTemp.put("Rooibos", 212);

// Remove all items:
teaSteepingTemp.clear();
System.out.println(teaSteepingTemp); // Prints: {}

### Finding a Hashmap size .size()

.size() returns the number of key-value pairs

Example: 
HashMap<String, Integer> teaSteepingTemp = new HashMap<>();
teaSteepingTemp.put("Oolong", 185);
teaSteepingTemp.put("Rooibos", 212);

// Output the size of a HashMap:
System.out.println(teaSteepingTemp.size()); // Prints: 2

### Traversing a HashMap for-each

in order to access each individual element in a HashMap you can use for-each loops: 


Example: 

HashMap<String, Integer> teaSteepingTemp = new HashMap<>();
teaSteepingTemp.put("Oolong", 185);
teaSteepingTemp.put("Rooibos", 212);
    
// Iterate through the HashMap:
for (String key : teaSteepingTemp.keySet()) {
  System.out.println("Brew " + key + " tea at " + teaSteepingTemp.get(key) + "°F");
}
/*
Prints:
Brew Oolong tea at 185°F
Brew Rooibos tea at 212°F
*/


### Additional HashMap Methods

.containsKey(key) 
- takes key as an argument and returns true or false depending on if the key is present in the HashMap

.replace(key, newVal)
- takes the key and new value and replaces value at that key with the new value input

.keySet()
- returns a Set containing all the key values in the HashMap

.values()
- returns a Collection containing all the values (without their keys)

.put(key, value); 
- Adds to the map

.containsKey(key); 
- Returns true or false

.get(key); 
- Returns the corresponding value


# Sets

A set stores *unordered* collection of unique Values. 

- creating a Set 
- adding items to a Set
- removing items from a Set 
- checking for an item 
- finding the size of a Set 
- iterating through a Set 
- using Set operations

## Set Types

Set is derived from the Collection class. It contains all the methods from the Collection class but ensures that every element is unique. 

There are different implementations, they all have the same methods and ensure to only store unique elements. 

### HashSet (default)

- HashSet implemented using a HashMap instance
- Order of elements are random 
- HashSet can store null values
- Hashset has a 0(1) runtime for .add()/ .remove() and contains() 
- *Hashset typically run faster than the other two options* 

### TreeSet 

- TreeSet implemented using a TreeMap instance
- Element order determined using comparator (alpha or numerical order)
- Treeset can NOT store null values 
- Treeset has slower runtime 0(log n) for .add(), .remove() and .contains()

### LinkedHashSet

- LinkedHashSet implemented using doubly linked list and a hash table. 
- Element order is determined by the order in which element is added
- Capable of storing a null value
- Has a 0(1) runtime for the .add(), .remove(), .contains() methods
- slightly slower runtime than a HashSet

## Creating a Set

*To use we must import the class* 

Example: 
// Import Set class:
import java.util.Set;

// Import HashSet class:
import java.util.HashSet;

// Import TreeSet class:
import java.util.TreeSet;

// Import LinkedHashSet class:
import java.util.LinkedHashSet;

// Import all classes:
import java.util.*;

- We have to declare the type and data type (reference types)

Example: 
// Create a HashSet that will contain String Values: 
Set<String> colours = new HashSet<String>(); 

// Create a TreeSet that will contain Integer Value: 
TreeSet<Integer> myNums = new TreeSet<Integer>(); 

## Set Methods Add/Remove/Size/Iteration

There are a variety of set methods that are available for all types of sets. 

- .add(item)
    colors.add("red");

- .remove(item)
    colors.remove("red");

- .size()
    colors.size();

- iterating: 
  for (String item: colors) {
  System.out.println(item);
}

## Using Set Operations

Set Class has several methods for different mathematical operations on two different sets

### Union .addAll()

Union of two sets will combine all values together. 

*Syntax:*
colors.addAll(primary)


Example: 
Set<String> colours = new HashSet<String>(); 
colours.add("red"); 
colours.add("orange"); 

Set<String> primary = new HashSet<String>(); 
primary.add("red"); 
primary.add("yellow"); 

colours.addAll(primary); 
System.out.println(colours); // Prints [red, orange, yellow]


### Intersection .retainAll()

retains all the overlaps i.e. preetn in both

*Syntax:* 
colours.retainAll(primary); 


*Example:* 
Set<String> colours = new HashSet<String>(); 
colours.add("red"); 
colours.add("orange"); 

Set<String> primary = new HashSet<String>(); 
primary.add("red"); 
primary.add("yellow"); 

colours.retainAll(primary); 
system.out.println(colours); // Prints: [red]

### Complement .removeAll()

complement stores value of one set after removing any overlapping values from another set. 

Placement Matters! The resulting set will contain only the values found only in the Set that the method is appended to. Any value that appears in the argument Set will be removed: 

*Syntax* 
colours.removeAll(primary)

*Example:* 
Set<String> colours = new HashSet<String>(); 
colours.add("red"); 
colours.add("orange"); 

Set<String> primary = new Hashset<String>(); 
primary.add("red"); 
primary.add("yellow"); 

colours.removeAll(primary); 
System.out.println(colours); // Prints: [orange]


# Coding Challenge - ArrayLists
## Loops involving ArrayLists: 
Say you are a beekeeper and each bee in your beehive is represented by your Bee class:

public class Bee {
  private String name;
  private boolean isHome;

  public Bee(String name) {
    this.name = name;
    this.isHome = true;
  }

  public String getName() {
    return this.name;
  }

  public void setName(String newName) {
    this.name = newName;
  }

  public boolean isHome() {
    return this.isHome;
  }

  public void leaveHome() {
    this.isHome = false;
  }

  public void returnHome() {
    this.isHome = true;
  }
} 


### PrintBees
- Write a method named printBees() that prints out the name of every bee in the bee list. Each name should be on its own line. 
/home/spencer/LearnJava/ArrayListChallenges/PrintBee

### Scavenger 
- A scavenger bee has to leave for an expedition! Given the name of the bee that has to leave home, update the corresponding bee in the beeList to be away.

- Each bee has an isHome property that determines where the bee is. To update this property to false, you can call the bee’s .leaveHome() method.

******** 

3. Moving In 

- Last night our Queen Bee had a long stay at the bee maternity ward! This morning we discovered that she added new members to our bee hive! Given an ArrayList of the names for our new bees, write a method, .addBees() to add the new bees into our beeList family.

4. Moving Out

- Some of the bees wanted to move out of the hive to make room for new family members. In .moveOutBees(), remove every other bee in the list of bees, starting with the first bee.

5. Strike

- Our bees are going on strike, and they demand new names! Given an ArrayList of newNames in .renameBees(), update each bee’s name to a name in the ArrayList at the corresponding index.

- For example, say we have the following names: {“jamie”, “alex”, “jeremy”}. The bee should index 0 should get the name “jamie”. The second bee should get the name “alex” and the third bee should get the name “jeremy”.

- If there are not enough names for every bee in the beeList, then you don’t have to update the names for the remaining bees. (We can talk to them to work out a compromise).


# Introduction to Dynamic Programming

A Programming technique used to solve recursive problems more efficiently. 

It increases time efficiiency by taking advantage of data structures to store reusable solutions to intermediate steps (saving redundant computations). 

Its a way of solving problems with recursive relaitonships by solving smaller problems and building up the solution to the original problem. 

## Fibonacci 
- Fibonacci series - each number is equal to the sum of the two before it always starting with 0 and 1-

*-*
0, 1, 1, 2, 3, 5, 8, 13, 21 etc. 
*-*

**Iteratively**
The 0th Fibonacci number is always 0. 
The 1st Fibonacci number is always 1. 
The 2nd therefor is 0+1=1 and 3rd 1+1=2. 

We could calculate the nth number this way (iteratively). 

**Recursively**
We could also calculate it recursively: 

fib(n)
  if n is 0 or 1
    return n
  else
    return fib(n - 1) + fib(n - 2)

This technique breaks up calculating nth number in to small steps: 

fib(n)
  if n is 0 or 1
    return n
  else
    return fib(n - 1) + fib(n - 2)

Can be visualised as a tree: 


         fib(5)
         /    \
     fib(4)   fib(3)
     /    \    /   \
  fib(3) fib(2) fib(2) fib(1)
  /   \    / \   / \
fib(2) fib(1) fib(1) fib(0)
 / \
fib(1) fib(0)

fib(5) is calculated by seperating in to fib(4) and fib(3). These are then further broken down until the base cases of fib(1) and fib(0). 

We have values for fib(1) and fib(0) as 1 and 0. 

We can now add up the numbers following up the tree to get to the value of fib(5) which is 5. 

- This requires such as large number of call and calculations with certain elements i.e. fib(2) being calculated multiple times. 

We can avoid this with *memoization* 

### Memoization 

Memoization is a specialised form of caching used to store the result of a function call. 

The next time that function is called, if the result is already stored somewhere, we trieve that instead of running again. 

Memoization can result in much faster overall execution. 

Memoization can increase memory requirements as functions results are stored in memory. 

Memoization is a great technique to use alongside recursion. The memo can even be saved between function calls if its being used for common calculations in a program. 

#### Memoizing Fibonacci 

We can use a Java HasMap to store memoized values. Each key will represent n (starting at 0). 

Then when we need to calculate a number its already been calculated and we can retrieve from the map in 0(1) time. 

*- Psuedo Code -*

Create a memo map

fibMemo(n, map)
  if n is 0 or 1
    return n
  if n key exists in map
    return map.get(n)
  else
    calculate current fibonacci number through a recursive call
    store value in map
    return value

/home/spencer/LearnJava/FibonacciMemoization/fibMemo.java : 
        public static int fibMemo(int n, Map<Integer, Integer> map) {
          if(n == 0 || n == 1) { 
            map.put(n, n); // Initializing base case for Fibonacci of 0
            map.put(n, n); // Initializing base case for Fibonacci of 1  
          }

          if (map.containsKey(n)) {
              // If the value is already computed, return it from the map to save computation
              return map.get(n);
          } else {
              // Compute the value for n by recursively calling fibMemo for n-1 and n-2
              int value = fibMemo(n - 1, map) + fibMemo(n - 2, map);
              // Store the computed value in map before returning
              map.put(n, value);
              return value;
          }
        }

## The Knapsack Problem

*The problem:*  
You are a thief breaking in to a house. You can only carry so much. Some is Diamonds, gold, jewelry. The goal is to maximise the total value while remaining in the weight. 

Total weight (weightCap)
weight of each item (weight)
value of each item (value)

ring      = 1lb | $250 
earrings  = 3lb | $300 
necklace  = 5lb | $500

Example: 
weightCap = 5 
weights = [1, 3, 5]
values = [250, 300, 500]

Outcome: 

ring + earrings = 5lb (inside weightcap) | $550 (highest value)

### Recursive solution

Brute force option is to configure every subset of the items then take the maximum value subset. 

To do this you would need the additional param i (where we are on the list). There are three posibilities for each call of this function: 

1. WeightCap or i is 0 (i.e. there is no weight available, there are no items avilable)

2. The weight of item were looking at exceeds weightCap so we move on to the next item 

3. if neither are true then we have to consider if this item should be incuded in the optimal solution

Example: 
static int knapSack (int weightCap, int weights[], int values[], int i)
    {        
        if (i == 0 || weightCap == 0) {
            return 0;
        }

        else if (weights[i - 1] > weightCap) {
            return knapSack(weightCap, weights, values, i - 1);

        } else {
            return : correct answerMath.max(
                   values[i - 1] + knapSack(: correct answerweightCap - weights[i - 1], weights, values, i - 1),
                   knapSack(: correct answerweightCap, weights, values, i - 1));
        }
    }

### The dynamic Approach

We can store information in a two-dimensional array that has a row for every item and weightCap+ 1 number of collumns. Each element will represent a subproblem with the element in the bottom right being the optimal solution. 

We are aiming to create a grid with the number of columns as there is weight capacity and the number of rows that there are items. 

Example items: 
Item 1 - 2 weight | 1 Value 
Item 2 - 4 weight | 3 Value 
Item 3 - 5 weight | 4 Value 
Item 4 - 6 weight | 5 Value

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0|
      1|
      2|
      3|
      4|

As we consider each row i.e. item, we consider if it's weight can be contained in that column and if so we input its value. Starting with the a capacity of 0 no item could fit in the bag. Equally with no items the bag is empty no matter the capacity so we can fill in these values. 

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
      1| 0 |
      2| 0 |
      3| 0 |
      4| 0 |

Now we can consider item 1. Item 1 has a weight of 2 so prior to the bag having a capacity of 2 the value of the bag is 0. When the capacity is 2 the value is the value of item 1 i.e. 1. Once item 1 is in the bag as the capacity of the bag continues to grow item 1 will be able to continue to fit in the bag

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
      1| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
      2| 0 |
      3| 0 |
      4| 0 |


When we get to the next row i.e. item 2, we consider this item and the item before. Item 2 has a weight of 4, as such nothing will change prior to the bag having this capacity. When it does have a capacity of 4 it will have the new highest value which is item 2's value of 3. This is the case until item 1 and 2 can fit (6 weight at column 6). Now both items can be added in the bag until the end. 

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
      1| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
      2| 0 | 0 | 1 | 1 | 3 | 3 | 4 | 4 | 4 | 4 |
      3| 0 |
      4| 0 |

The following item is now considered with the other items. Item 3 has weight 5 so nothing changes until then. Item 3 and item 1 have weight 6 so they can be combined at column 6. Item 3 and item 2 can be combined at column 9 and so this also increases. 

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
      1| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
      2| 0 | 0 | 1 | 1 | 3 | 3 | 4 | 4 | 4 | 4 |
      3| 0 | 0 | 1 | 1 | 3 | 4 | 5 | 5 | 5 | 5 | 
      4| 0 |

The same is repeated for the final row with the maximum profit being calculated at each level. We know that item 4 has weight 6 and so the numbers prior i.e. the combination will not change until column 6. 

**Therefor we do not need to calculate these values** 

            Weight
       | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
Item  0| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
      1| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
      2| 0 | 0 | 1 | 1 | 3 | 3 | 4 | 4 | 4 | 4 |
      3| 0 | 0 | 1 | 1 | 3 | 4 | 5 | 5 | 5 | 5 | 
      4| 0 | 0 | 1 | 1 | 3 | 4 | 5 | 5 | 6 | 6 |

- Here you will see the bottom right number will always be the highest value 

/home/spencer/LearnJava/KnapSack/Knapsack.java

## Capturing Rainwater

*The Problem*

Heavy rainstorm over a highway with many potholes. The rainwater will collect in the empty holes creating puddles. Each pudddle can only get as high as the road surrounding it, any excess will flow away.

The problem asks you to imagine water fell over a histogram (chart with a series of bars). How much rainwater would ge trapped in the spaces between these bars
4 _  __
    |  |
3 _ |  |      __
    |  |     |  |
2 _ |  |__   |  |      __
    |  |  |  |  |     |  |
1 _ |  |  |__|  |   __|  |
    |  |  |  |  |  |  |  |
0 __|__|__|__|__|__|__|__|
    [4  2  1  3  0  1  2 ]
      
This is how it would look filled with water: 

4 _  __
    |  |
3 _ |  | 1 2  __
    |  |WMWMW|  |
2 _ |  |WMWMW|  |2  1  __
    |  |  |MW|  |MWMWM|  |
1 _ |  |  |MW|  |MWMWM|  |
    |  |  |  |  |MW|  |  |
0 __|__|__|__|__|MW|__|__|
    [4  2  1  3  0  1  2 ]

The water would fill in a total of 6. 

### The Concept/ Foundation

The amount of rainwater at any given space is the difference between: 

1. The highest bar on the left vs the highest bar on the right 
2. the height of the bar at the given index
// Math.min returns the smallest of the numbers given as an input

waterAtIndex = Math.min(highestLeftBound, highestRightBound) - heightOfIndex;

// Math.min(highestLeftBound, highestRightBound) - this calculates which side is the lowest and where the water will run out from first

// - height of index - this takes what the floor of the puddle is 

// the final water level therefor is the floor of the puddle to where the water runs out

#### Naive Solution: 

1. Traverse every element in the array
2. Find the highest left bound for the current index
3. Find the highest right bound for the current index
4. Take the lower of these two values
5. Subtract the height of the current index from that lower value
6. Add the difference to the total amount of water captured

Example: 
    public int naiveSolution(int[]heights) {
        int totalWater = 0;
        for (int i = 0; i < heights.length - 1; i++) {
            int leftBound = 0;
            int rightBound = 0;
            // Here we only want to look at elements to the LEFT of index i, which are the elements at the lower indices
            for (int j = 0; j <= i; j++) {
                leftBound = Math.max(leftBound, heights[j]);
            }
            // Now here we only want to look at elements to the RIGHT of index i, which are the elements at the higher indices
            for (int j = i; j < heights.length; j++) {
                rightBound = Math.max(rightBound, heights[j]);
            }
            // Add the amount of water at index i to totalWater
            totalWater += Math.min(leftBound, rightBound) - heights[i];
        }
        return totalWater;
    }

**_**
While this is a functional solution, it requires nested for loops, which means it has a big O runtime of O(N^2). Let’s now look at a solution with a more efficient runtime!

#### The optimised solution: 

It is possible to solve this problem in 0(N) time by using the two-pointers approach. One pointer starts at the beginning of the array and one starts at the end. They move towards each other. 

___
totalWater = 0
leftPointer = 0
rightPointer = heights.length - 1
leftBound = 0
rightBound = 0
___

Left and right ponter will start at the beginning and end and move towards until they meet. 

while leftPointer < rightPointer:
    if the element at leftPointer <= the element at rightPointer:
        -set leftBound to max value between leftPointer element and leftBound
        -add difference between leftBound & the element at leftPointer to totalWater
        -move leftPointer forward by one
    else:
        -set rightBound to max value between rightPointer element and rightBound
        -add difference between rightBound & the element at rightPointer to totalWater
        -move rightPointer back by one 

return totalWater

/home/spencer/LearnJava/RainWater/RainWater.java

## Sieve of Erathosthenes

The Sieve of Erathosthenes is one of the oldest-known algorithms. 

The sieve provides a set of steps for finding prime numbers up to a given limit. 

Reminder: 
A prime number is a number with no divisors but 1 and itself. 

### The Sieve implementation

The Sieve works by assuming all numbers are prime and then successuvely marking them as NOT prime. 

{2,.......,n}

The algorithm works as follows: 

1. Create a list of all integers from 2 to n.
2. Start with the smallest number in the list (2, the smallest prime number).
3. Mark all multiples of that number up to n as not prime.
4. Move to the next non-marked number and repeat this process until the entire list has been covered.

When the steps are complete, all remaining non-marked numbers are prime.

Example: 
Wanting all numbers that are prime up to 10

- Start with a list 

  2 3 4 5 6 7 8 9 10

- Start with 2, mark all multiple up to 10 as not prime

  2 3 X 5 X 7 X 9 X

- Move to the next non marked number i.e. 3 

  2 3 X 5 X 7 X X X

- Continue with each unmarked number, in this case all of them are marked so this is the result. 

  2 3 X 5 X 7 X X X

#### Implementing in Java

import java.util.*;

class FindTrueIndices {

   void findTrueIndices(boolean[] arr) {
    // Create an ArrayList to store the indices of elements that are true
    ArrayList<Integer> result = new ArrayList<>();

    // Loop through the boolean array to find true values
    for (int i = 0; i < arr.length; i++) {
        if (arr[i]) { // Check if the current element is true
            result.add(i); // Add the index of the true element to the result list
        }
    }

    // Print the indices of elements that are true
    System.out.println(Arrays.toString(result.toArray()));
  }

  public static void main(String[] args) {
    FindTrueIndices myFindTrueIndices = new FindTrueIndices();
    boolean[] testValues = {false, false, true, true, false, true, false, true};
    myFindTrueIndices.findTrueIndices(testValues);
  }
}

#### Optimisations

##### End Boundary 

In our basic implementation the outer loop iterated from 2 to n Because the inner loops marks multiples of a base value. we only need to check individual nubers lower than the square root of n. Consider the example of a limit of 10. 

1. First, all multiples of 2 are marked:

  2 3 X 5 X 7 X 9 X

2. Then, all multiples of 3 are marked:

  2 X X 5 X 7 X X 10

3. 4 is greater than the square root of 10 (approximately 3.16), so we can break. If you look at the previous step, all non-prime numbers have indeed already been marked.


##### First Multiple

In our basic implementation the inner loop started checking multiple at 2 times the current number. We can skip a few checks starting the checks at current^2. 

1. First, all multiples of 2 are marked:

  2 3 X 5 X 7 X 9 X

2. Then, all multiples of 3 are marked, but we can skip 6 (3 * 2) because it’s already been marked. Instead we start at 3^2 i.e. 9: 

  2 3 X 5 X 7 X X X

3. We’ve now completed the check with one less comparison.

##### Pre-mark All Even Numbers: 

This optimization comes in when building the initial array. There’s no need to ever check even numbers after 2, since they will never be prime, so they can all be marked as non-prime initially.

#### Complexity

The complexity of the Sieve with optimisations is 

    O(n log(log n))

#### Conclusion: 

import java.util.*;

public class SieveOfEratosthenes {
    void sieveOfEratosthenes(int limit) {
        boolean[] output = new boolean[limit + 1];
        for (int x = 0; x <= limit; x++) {
            output[x] = true;
        }
        output[0] = false;
        output[1] = false;

        for (int i = 2; i <= Math.pow(limit, 0.5); i++) {
            if (output[i] == true) {
                for (int j = (int) Math.pow(i, 2); j <= limit; j = j + i) {
                    output[j] = false;
                }
            }
        }

        List<Integer> result = new ArrayList<Integer>();

        for (int i = 0; i < output.length; i++) {
            if (output[i] == true) {
                result.add(i);
            }
        }

        System.out.println(Arrays.toString(result.toArray()));
    }

public static void main(String[] args) {
        int n = 7;
        SieveOfEratosthenes g = new SieveOfEratosthenes();
        g.sieveOfEratosthenes(n);
    }

}
