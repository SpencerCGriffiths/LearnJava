Java Orignal designed and released in 1995. Object Oriented Programming Language. 

The Java Virtual Machine (JVM): 

The JVM is responsible for taking in Java bytecode and executing the instructions of a program. 

The JVM made Java popular as it allows a Java program to run the same way on different OS and Platforms. 

This is why Java has the slogan WORA (write once, run anywhere).

Cycle of a Java Program: 

Code is written in a .java file. When run this is converted to bytecode (a machine language). The bytecode is sent to the JVM where it is analysed and then executed. The JVM terminates once it executes the final instruction. 

Note: The Java compiler turns the code to bytecode and the JVM then interprets. The JVM is not a compiler. 

!!!!!!
Syntax

Google has compiled a guide: https://google.github.io/styleguide/javaguide.html to find something specific. 

Naming Conventions: 

Java uses Camel case for most names. 

Class and Interface names use PascalCase i.e. LinkedList. 

Constants use SNAKE_CASE i.e. VALUE_OF_PI.

Brackets and Parentheses: 

Brackets must be used for all method and class declarations, conditionals and loops with multiple lines. 

They can be omited for single line but better for readability. 

if (true) {
    return false; 
}

Indentations and Spacing: 

Amount of indentation and white space does not affect compiling or runing. 

However, spacing should be added for readability. 


!!!!!
Downloading Java:

There are many IDE's that can run Java but it can also be run from the command line. 

Your computer most likely has the Java Runtime Environment to run programs. It compiles Java Bute Code from generic files to be run specificaly on your type of computer. 

As a Developer you need the Java Development Kit (JDK). Allowing you to access classes and interfaces of teh core Jaa language. 

There are a variety of versions of JDK at: https://www.oracle.com/java/technologies/downloads/. However most development occurs in standard edition (SE). 

!!!!
Compiling Java:

Before running a program in the command line it muse be compiled. Navigate to where the file is you want to run and use e.g. 

``` 
javac MyClass.java
```
This creates the .class file that can be executed. If there are any bugs they will be flagged at this point and the file will not be created. 

!!!
Running Java 

Once Executable you can run it using: 

```
java MyClass 
```

(omit the .java or .class suffix)

Complete example:  !!! <---- Very Important: 

file: HelloWorld.java contains: 

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}

CLI: 

javac HelloWorld.java 

Output: HelloWorld.class created

java HelloWorld

output: Hello world!


Main Method Params !!! <---- Very Important: 

Every main method contains the params String[] args. This means that args is an array of strings. We can use these in our class if we wish. 

All arguments passed in the cli will be treated as strings and so numbers need to be parsed.

Some files will have a main method and others will not. When we use the java command we are specifying which java class that we should look for the main method in. 

Complete example:  !!! <---- Very Important: 

file: HelloWorld.java contains: 

public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello world, my name is " + args[0] + "!");
  }
}

CLI: 

javac HelloWorld.java 

Output: HelloWorld.class created

java HelloWorld Batman

output: Hello world, my name is Batman!


!!!!
Hello World and Class Structure

Class Structure: 
Object-oriented programming consisting of classes and methods. Java only has methods and no functions. 

Classes: 
Public - Can be accessed from any other class or method in the environment. 

Private- restricts the visibiliy of a class to within the parent class e.g. 

public class MyClass {
    private int privateVariable;  // Only accessible within MyClass

    private void privateMethod() {
        // Only callable within MyClass
    }
}

i.e. in Java the top level cannot be private otherwise it could never be called. 

Protected- Middle ground whereby the protected member is accesibile within the ame package and in subclasses even in different packages. 

e.g. 
public class BaseClass {
    protected void protectedMethod() {
        // Accessible in subclasses and in the same package
    }
}

public class DerivedClass extends BaseClass {
    void accessMethod() {
        protectedMethod();  // Allowed access
    }
}

Methods: 
Every Java program must have a method called main(). This main method holds all of the instructions for the program (the master method that controls the whole program). As noted this main method always has String[] args. 

e.g.
/home/spencer/LearnJava/CodingExamples/HelloWorld/HelloWorld.java

!!! 
Print Statements 

Print Statements: 
system.out.print("Some Text");
prints on the line. If you system.out.print they will print next to each other: 
system.out.print("Some Text");
system.out.print("Some Text");
Output: 
Some TextSome Text

system.out.println("Some Text");
prints and then creates a new line for the next piece of text. 
system.out.println("Some Text");
system.out.print("Some Text");
Output: 
Some Text
Some Text

!!!
Comments

inline Comments: 
// Here is a comment

Block comments: 
/* Here is some text that could be 2 lines */ 

!!!
Variables and Types

Declaring: 
When declaring a variable the dataType must be declared. 

Syntax <- important-> 
dataType variableName = value;

dataType variableName;

dataType variableName;

Data Types: 
int- 
Whole numbers 
*between -2147483648 and 2147483647
e.g. int moonLanding = 1969;

double- 
Decimals
*4.9E-324 and 1.7976931348623157E+308:
e.g. double PI = 3.14;

boolean- 
true or false
e.g. boolean isRaining = true;

char 
single character
e.g. char firstLetter = 'a';


Manipulating Number-Based Variables: 
Mathmatical symbols are valid syntax as in JavaScript i.e. 

int num = 3 + 2; // num now equals 5
num = num - 1; // num now equals 4

you can increment and decrement: 
++ -- 

and compound: 
+= 

!!!!
Strings

strings are a reference data type as they are objects from the String class. 
e.g. String greetings = "Greetings, earthlings!"

!!!!
Conditional Statements and Comparison Operators

if: 

if (expression) {
  // Code to run if expression is true
}

else: 

if (expression) {
  // Code to run if expression is true
} else {
  // Code to run if expression is false
}

if- else: 

if (expression) {
  // Code to run if expression is true
} else if (expression) {
  // Code to run if previous expression is false and current condition is true
} else {
  // Code to run if all previous expressions are false
}

Comparison Operators: 
e.g.
&& - and 
|| - or 
! - not 
== - equal to 
!= - not equal to 
etc. 

!!!
Loops

While: 

while (num < 20) {
  num = num + 1;
}

do-while: 

do {
 System.out.println("2 is equal to 4!");
} while (2 == 4);

for: 

for (int i = 0; i <= 10; i++) {
  System.out.println(i);
}

for each: 

for (String s : myArray) {
  // Do something
}
(each element in the array is a string, s holds the value of the element in the loop, myArray is what is being iterated)

break: 
Used to exit a loop- 

for (int i = 0; i < 10; i++) {
  System.out.println(i);
  if (i == 4) {
    break;
  }
}

continue: 
continue will skip an interation if true and go to the next iteration without exiting the loop altogether. 

for (int i = 0; i < numbers.length; i++) {
  if (numbers[i] % 2 == 0) {
    continue;
  }
  System.out.println(numbers[i]);
}

!!!
User-Defined Methods

Anatomy of a Method: 

public static void exampleMethod() {
  System.out.println("Hello Method!");
}

public method- can be accesed by any part of the program. 

static method - can be called throughout a program without creating an object of the class 

void method- does not return a value 

empty brackets- this method takes no params

(A method is called with exampleMethod() )

!!!
Params and Arguments: 

Parameters are the holders that are put in place when declaring the method i.e. 
public static void exampleMethod(String greeting, String name) {
  System.out.println(greeting + " " + name);
}

Arguments are what are passed when it is invoked: 
public static void main(String[] args) {
  exampleMethod("Greetings", "Earthling");
}

!!! 
Returning: 

if the function is returning then the data type to be returned needs to be declared 

e.g. 
public static int findProduct(int num1, int num2) {
  return num1 * num2;
}
public static void main(String[] args) {
  int product = findProduct(3,4);
  System.out.println(product); // Prints: 12
}

String Methods: 

.length() - length

.concat() - concatenates - adds to end of another string e.g. name.concat("cademy")

.equals() - checks equality as we cannot use == with strings. e.g. flavor1.equals("Mango")

.indexOf() - index of the first occurence of a char. e.g. letters.indexOf("C") 

.charAt() - returns char at the index. e.g. currency.charAt(2)

.substring() outputs the string split. One arg will cut from that index to end. Two is the beginning and then end index. e.g. line.substring(7, 24)

.toUpperCase() / .toLowerCase() - Makes all chars upper or lower case. 


Code Challenge: 

1. Leftover Funds
We start with 0 burritos, and a quantity of money. Update the code to return false or true as to whether there is left over funds. 

CodingExamples/BurritoCalculator/BurritoCalculator.java

2. Burritos Sold
Update the function to work out how many Burritos sold. 

CodingExamples/BurritoCalculator2/BurritoCalculator2.java

Code Challenge: 

1. Create new string with chars reversed
CodingExamples/Reverse/Reverse.java 

2. Find if one or more substrings has a problem
CodingExamples/Replace/Replace.java

!!!
Arrays

Declaring an empty array: 
(this declares and tells the machine that there will be a an array with this name created in the future but currently this does not point to an actual space in memory! - see create empty array)

int[] lottoNumbers;
String[] clothingItems;

Declaring a populated array:

int[] lottoNumbers = {12, 29, 4, 38, 3};
String[] clothingItems = {"Huipil", "Beanie", "Kimono", "Sari"};

Accessing an element by index: 
(0 indexed)

String[] clothingItems = {"Huipil", "Beanie", "Kimono", "Sari"};
clothingItems[2];

Changing an Elements Value: 

arrayName[index] = newValue;


Create an Empty array: 
(this initialises the array and populates it with empty null values)

dataType[] emptyArrayName = new dataType[number of elements in array];

.length: 
provides the number of elements

e.g:
lottoNumbers.length

for loop: 

e.g.
for (int i = 0; i < lottoNumbers.length; i++) {
  // action
}

for-each loop: 

e.g
int[] lottoNumbers = {12, 29, 4, 38, 3};
for (int num: lottoNumbers) {
  System.out.println(num);
}

Example: 
CodingExamples/ArraysExample/ArraysExample.java

!!!
2D Arrays

A two dimensional array is an array that stores arrays of the same data type

i.e. 

[["a","b","c"],["d","e","f"],["g","h","i"]]

Declaring a 2D array: 

dataType[][] variableName; 

e.g.
int[][] nums;


Declaring and populating:

int[][] nums = {{10, 9, 8}, {7, 6, 5}, {4, 3, 2}}; 

Accessing an element in a 2D array: 

arrayName[firstIndex][secondIndex]

e.g. 

int[][] nums = {{10, 9, 8}, {7, 6, 5}, {4, 3, 2}}; 
// Within the first array, access the second element:
System.out.println(nums[0][1]); // Prints: 9

Updating a value: 

this is the same as a standard array using the assignment operator

e.g.
char[][] letters = {{'A', 'a'}, {'B', 'x'}, {'C', 'c'}};

// Update the value:
letters[1][1] = 'b';
System.out.println(letters[1][1]); // Prints: b

creating an empty 2D array: 
As with a normal array the length of the array needs to be qualified. 



e.g
int[][] intArray = new int[2][3];

!!! 
Row- Major Order

Traversal path that moves horizontally through each row starting at the first to the last i.e. 

[[1, 2, 3],
[4, 5, 6],
[7, 8, 9],
[10, 11, 12]]

Can be done with an outer and inner loop: 
Outer loop iterate the length of the array counted the nested arrays. 
Inner loop counts the elements in the nested array. 
Once a nested array completed it will move on to the next iteration of the outer loop which is the next array. 

for (int i = 0; i < letters.length; i++){
  for (int j = 0; j < letters[0].length; j++){
    System.out.print(letters[i][j]);
  }
}

Column- Row Order

Traversal path that moves vertically down each column starting with the first to last. 
i.e. 

[[1,5,9,13],
[2,6,10,14],
[3,7,11,15],
[4,8,12,16]]

nested for loop: 
Outer loop iterate the length of a nested array
inner loop iterate the number of nested arrays. 
Outer loop targets the column whilst inner loop targets the row. 

e.g. 
for (int i = 0; i < letters[0].length; i++){
  for (int j = 0; j < letters.length; j++){
    System.out.print(letters[j][i]);
  }
}

Arrays.sort()  - to sort arrays alphanumerically etc. 

Array Lists have mutable size (you can add and remove elements freely). 

Challenges: 

1. Total cost for Groceries
CodingExamples/GroceryList/GroceryList.java

2.  Most Expensive Grocery Item
CodingExamples/GroceryList2/GroceryList2.java

3. Lengthy Groceries
CodingExamples/LengthyGroceries/LengthyGroceries.java

4. Special Item 
/home/spencer/LearnJava/CodingExamples/HasSpecialItem/HasSpecialItem.java

5. Alphabetical Items
/home/spencer/LearnJava/CodingExamples/isAlphabetised/isAlphabetized.java

6. Duplicate Items
/home/spencer/LearnJava/CodingExamples/HasDuplicates/HasDuplicates.java

7. Reverse the array of Groceries
/home/spencer/LearnJava/CodingExamples/ReverseGroceries/ReverseGroceries.java

8. 
/home/spencer/LearnJava/CodingExamples/RotateArray/RotateArray.java

## Code Challenge: Traversing 2D Arrays

Traversing a 1D Array: 
/home/spencer/LearnJava/CodingExamples/KoalaCounting/KoalaCounting.java

Traversing a 2D array: 

Add up the numbers in the nested 2D array
/home/spencer/LearnJava/CodingExamples/GetTotal/GetTotal.java

Searching for a Value in a 2D array: 
searching through 2D array to find values that meet a certain condition- 
/home/spencer/LearnJava/CodingExamples/FindValueGreater/FindValueGreater.java

Find the collumn with Largest Value: 
search array by column rather than row to find largest column array- 
/home/spencer/LearnJava/CodingExamples/LargestValue/LargestValue.java

---

# Classes and Constructors 

1. General Structure
2. Access Modifiers 
3. Constructors

## Classes 

A class is the set of instructions that describe how an instance can behave and what information it contains. Java has predefined classes such as System but we can create our own. 

**Structure of a Class**

  public class Car {

    public static void main(String[] args) {

    }

  }
  
**Access Modifiers**: 
  Public is an access level modifier that allows other classes to interact with this class. There are four types of access modifiers

Modifier    | Class | Package | Child Class | Global |
Public      |   X   |    X    |       X     |   X    | 
Protected   |   X   |    X    |       X     |   -    |
no modifier |   X   |    X    |       -     |   -    |
private     |   X   |    -    |       -     |   -    |

**Constructors**
In order to create an object (instance of a class) we need a constructor method. 

  public class Car {
    // Constructor method:
    public Car() {
      // Instructions for creating a Car instance
    }  

    public static void main(String[] args) {

    }
  }

To create an instance we need to call/invoke the constructor within main(). The following example assigns a Car instnace to the variable ferrari. 

  public class Car {

    public Car() {
      // Instructions for creating a Car instance
    }
  
    public static void main(String[] args) {
      // Invoke the constructor:
      Car ferrari = new Car(); 
    }
  }

In this example the variable ferrari is declared as *reference data type*. The value of ferrari is a reference to an instance in memory. 

The **new** keyword is essential as it indicates a new instance of car(). Omitting it causes an error. 

The value of ferrari is currently its memory address i.e. : Car@76ed5528

**Invoking the Constructor** 

When we create a new instance we invoke the constructor. Any code inside the constructor will be executed- 

Example:

  public class Car {

    public Car() {
      System.out.println("I'm a constructor!");
    }
  
    public static void main(String[] args) {
      // Invoke the constructor:
      Car ferrari = new Car(); // Prints: I'm a constructor! 
    }
  }

## Object State and Behaviour

In Java an object is a specific instance of a class.

- Creating an object
- Object state 
- Object behaviour 
- the .toString() method

### Creating an Object 

Objects and classes are closely related. Classes define the attributes and behaviours of an object. 

To create an object declare a variable in the main() method with the class name as the data type and set the value to a call to the class constructor. 

The class name is used as the data type because objects have reference data types (the value of the variable is a reference to an instance memory address)



Example: 
  class Cat {
    // Class constructor:
    public Cat(){
      // Instructions for creating an instance of Cat goes here:
    }

    public static void main(String[] args) {
      // Create a Cat object by calling the constructor:
      Cat myCat = new Cat();
    }
  }


      Cat myCat = new Cat();

*Cat* - is the data type, it is a reference to the class Cat 

*myCat* - is what we are naming the variable which is a instance of Cat. 

*new* - must be used to invoke a new instance

*Cat()* - is invoking the Cat() method within the class Cat. 

### Object State

State refers to the attributes of an object.

State can be defined using instance variable, or instance fields, which are placed inside of a class. 

**Creating Instance Fields**

To create an instance field, initialise variables inside the class container

Example: 
  class Cat {
    // instance fields:
    String noise = "meow";
    int numLives = 9;
    
    public Cat(){
      // Instructions for creating an instance of Cat goes here:
    }

    public static void main(String[] args) {
      Cat myCat = new Cat();
    }
  }

To access an objects instance fields, append the dot operator followed by the instance fields name to the name of the object: 

Example: 
  Cat myCat = new Cat();
  // Access instance variable of an object:
  System.out.println(myCat.noise); // Prints: meow

### Defining State with Parameters

To create dynamic objects, parameters can be added to the class constructor. Instance variables can then be assigned the parameter values. 

Example: 
  class Cat {
    // Instance fields:
    String noise;
    int numLives = 9;
    
    // Constructor takes in one String parameter
    public Cat(String animalNoise){
      // Assign instance variable to parameter value:
      noise = animalNoise;
    }

    public static void main(String[] args) {
      // Send argument to constructor when creating an object:
      Cat firstCat = new Cat("mew"); 
      // Send argument to constructor when creating another object:
      Cat secondCat = new Cat( "mow");
      
      System.out.println(firstCat.noise); // Prints: mew
      System.out.println(secondCat.noise); // Prints: mow
    }
  }

#### THIS 

**The this keyword**

the *this* keyword is used to reference the current object. 

Example: 
  class Cat {
    String noise;
    int numLives = 9;
    
    // Parameter has same name as the instance variable
    public Cat(String noise){
      // Assign instance variable to parameter value:
      this.noise = noise;
    }
  }

### Object Behavior 

**Non-Static Methods** 

We can give objects functions (behaviours) by using non-static methods. This is a "method" (function) that belongs to the class. These are declared without the static keyword 

Example: 
  class Cat {
    String noise;
    int numLives = 9;
  
    // Non-static method:
    public void speak() {
      System.out.println(noise);
    }
    
    public Cat(String animalNoise){
      noise = animalNoise;
    }

    public static void main(String[] args) {
      Cat myCat = new Cat("mew");
    }
  }

**Invoking non-static method** 

A non static method can be invoked following a . with the method name 

Example: 
  Cat myCat = new Cat("mew");
  // Invoke non-static method on an object:
  myCat.speak(); // Prints: mew


#### .toString()

the toString() method can be added to a class in order to create a unique output when printing an object. The original toString() exists in the Object class but is often overridden for a unique output

Example: 
  class Cat {
    String noise;
    int numLives = 9;
  
    public String toString() {
      return "The cat with " + numLives + " lives says " + noise;
    }
    
    public Cat(String animalNoise){
      noise = animalNoise;
    }

    public static void main(String[] args) {
      Cat myCat = new Cat("mew");
      System.out.println(myCat); // Prints: The cat with 9 lives says mew
    }
  }

## Getter and Setter Methods

When making a class we often make the variables *private*. We might want other classes to access them but not to know the exact variable name. 

### Accessor Methods (Getter)

To give other classes access to private instance variables we would write an accessor method

Example: 
  public class Dog {
    private String name;
      
    // Other methods and constructors

    public String getName() {
      return name;
    }

    public static void main(String[] args) {
      Dog myDog = new Dog("Lassie");
      System.out.println(myDog.getName()); // Prints: Lassie
    }
  }

Name is a private variable i.e. cannot be accessed outside the class. However getName() is provided in order to retrieve (or *get*) the value of this variable. 

### Mutator Methods (Setter)

These methods allow other classes to reset the value stored in private instance variable 

Example: 
  public class Dog {
    private String name;
      
    // Other methods and constructors

    public void setName(String newName) {
      name = newName;
    }

    public static void main(String[] args){
      Dog myDog = new Dog("Cujo");
      myDog.setName("Lassie");
    }
  }

Mutator methods are often *void* i.e. have no return value they just reset the value. Similarly often only have one parameter that is the thing they are designed to mutate/Set. 

# Scope

scope defines where a variable or method is accesible from in a program 

- Types of variable scope 
- Access modifiers

**Variable Scope** 

1. Class Level Scope 
2. Method Level Scope 
3. Block Scope

## Class Level Scope

Any variable declared within a class is accesible by all methods in that class. Depending on access modifier (public/private) can sometimes be accessed outside the class. 

Example:
  public class Car {
    public String color;
    private int speed;

    public Car(String color, int speed) {
      // Variables color and speed accessible here
    }

    public void drive(boolean fourWheel) {
      // Variables color and speed accessible here
    }
  }

  public class BuyCar {
    public static void main(String[]args) {
      Car carObject = new Car("blue", 70);
      // Can access the public variable, color, in this class
      String carColor = carObject.color;
      // Can’t access the private variable, speed, in this class
      // int carSpeed = carObject.speed -- This results in an error, can’t access speed here
    }
  }

## Method Level Scope

Anything declared in the method is not accesible outside that method. 

Example: 
  public class Car {
    public String color;
    private int speed;

    public void drive(boolean fourWheel) {
      String tires = "wide";
      // fourWheel and tires are only accessible here
      // fourWheel and tires are destroyed after drive() finishes
    }

    public void paint(String newColor, String oldColor) {
      // newColor and oldColor are only accessible here
      // newColor and oldColor are destroyed after paint() finishes
    }
  }

  public class PaintCar {
    // The only variable from Car accessible in this class is color
    // None of the variables declared in Car methods are accessible in this class
  }

## Block Scope

Any variable declared in a for loop not accesible outside of that loop/block

Example: 
  public class Car {
    public void changeTires() {
      int numTires = 4;
      int changedTires = 0;
      for (i = 0; i < numTires; i++) {
        changedTires += 1;
      }
      // numTires and changedTires are accessible here, i is not
    }
  }

## Access Modifiers 

there are four access modifiers that restrict the accesibility of the method or variable. They are only used within classes not within methods 

1. Private
2. Default 
3. Protected
4. Public

### Private

*Most* restrictive. limits access to methods and variables to the **class** that they are declared in. Chosen when methods or variables not needed outside the class. 

### Default (no modifier)

Allows access only from within the current **package**. If not specified the method or variable will take this on. 

### Protected

Allows access to method/variable from within the current package *unless* it is accessed through a child class outside the package. 

### Public

The *least* restrictive modifier. Allows acces to class/method/variable from the class and outside the class. 

### Example: 
  public class MinHeap {
    public ArrayList<Integer> heap;
    public int size;

    public MinHeap() {
      // Body of constructor
    }
    public void add(int value) {
      heap.add(value);
      size++;
      bubbleUp();
    }
    private void bubbleUp() {
      // Body of .bubbleUp() method
    }
  }

  public class TrackAges {
    public static void main(String[]args) {
      MinHeap ages = new MinHeap();
      // Can call public MinHeap .add() method here:
      ages.add(42);
      ages.add(15);
      ages.add(27);
      // Can’t call private MinHeap .bubbleUp() method here
      // Don’t need to because .add() calls .bubbleUp()!  
    }
  }

# Inheritance

- Superclasses and Subclasses 
- the super() method
- access modifiers

## Superclasses and Subclasses (extends)


Superclasses- 
The class that another class inherits from. 

Subclasses- 
The class that inherits qualities from another class. 

An object/instance of a subclass inherits all the available instance variables and methods in the superclass. 

In order to create this relationship the Subclass has to **extends** the Superclass- 

Example: 
  class Shape {
    Shape() {
      System.out.println("I am a shape!");
    }
  }
  // Make Triangle a subclass of Shape:
  class Triangle extends Shape {
    Triangle() {
      System.out.print("I am a triangle!");
    }
    public static void main(String[] argos) {
      Shape sq = new Shape(); // Prints: I am a shape!
      Triangle tri = new Triangle();
      /* Prints:
      I am a shape!
      I am a triangle!
      */
    }
  }

### The super() Method

When an instance of a subclass is created the subclass constructor will automatically invoke the superclass constructor. 

The *super()* method allows us to control what arguments are sent to the superclass constructor when creating an object of the subclass. 

To invoke the *super()* method place it in the body of the subclass constructor. 

Example: 
  class Shape {
    int numSides;
    Shape(int numSides) {
      this.numSides = numSides;
    }
  }
  
  class Triangle extends Shape {
    Triangle() {
      // Use super() to call the Shape constructor:
      super(3);
    }

    public static void main(String[] args) {
      Shape sq = new Shape(4);
      Triangle tri = new Triangle();
      System.out.println(sq.numSides); // Prints: 4
      System.out.println(tri.numSides); // Prints: 3
    }
  }

# Polymorphism 

Allows a subclass to share information and behaviour of its superclass while also incorporating its own functionality. 

- Using Methods of a superclass 
- Overriding superclass methods
- Using a subclass in place of its superclass 

## Using Methods of a Superclass

The methods of the Superclass are available to the subclass with .method()

Example: 
  // Parent class:
  class Bird {
    public Bird() {
      // Instructions for creating a Bird go here:
    }

    public void move() {
      System.out.println("The bird flies away");
    }
  }
  
  // Child class:
  class Flamingo extends Bird {
    public Flamingo() {
      // Instructions for creating a Flamingo go here:
    }
  
    public static void main(String[] args) {
      Flamingo myFlamingo = new Flamingo();
      myFlamingo.move(); // The bird flies away
    }
  }

## Overriding Superclass Methods

If we want a subclass method to behave differently to the superclass method we can override the method. It must have the same name (signature) and also use *@Override*

Example: 
  // Parent class:
  class Bird {
    public Bird() {
      // Instructions for creating a Bird go here:
    }

    public void move() {
      System.out.println("The bird flies away");
    }
  }
  
  // Child class:
  class Penguin extends Bird {
    public Penguin() {
      // Instructions for creating a Penguin go here:
    }
    
    // Override the parent class method:
    @Override
    public void move() {
      System.out.println("The penguin waddles away");
    }
  
    public static void main(String[] args) {
      Penguin myPenguin = new Penguin();
      myPenguin.move(); // Prints: The penguin waddles away
    }
  }

## Using Subclass in place of its Superclass

Polymorphism makes it possible to send an instance of a subclass somewhere where an instance of the superclass is expected. 

**Creating an Instance** 

We can use the superclass as the reference data type when creating a new object from a subclass. 

Example: 
Superclass  = Plant 
Subclass    = Succulent 

You can create an insance with a declared type "plant" but an actual type of Succulent: 

Plant echeveria = new Succulent();

### Creating Arrays or ArrayLists 

Arrays and Array Lists can only contain values of the same type. If we declare objects as "reference type" to the superclass we can store all of the instances in one array. 

i.e. if there is a Monster superclass and subclasses Vampire, Werewolf, Zombie etc. We can create a Monster type array list. 

Example: 
Monster dracula, wolfman, evilZombie;
 
dracula = new Vampire();
wolfman = new Werewolf();
evilZombie = new Zombie();
 
Monster[] monsters = {dracula, wolfman, evilZombie};

### Sending an Object as a Parameter

If a method or constructor parameter requires an object of a superclass to be passed in when it is invoked, we can send an object of the subclass as an argument. 

If cat is a subclass of Animal we can use an instance of Cat as an argument. 

Below in Class Vet there is a method getCheckUp(). This take a type *Animal* parameter name *patient*. 

When calling the getCheckup method we can pass a instance of an Animal i.e. myCat. 

Example: 
  class Vet {
    public void Vet() {
      // Instructions for instance go here:
    }
    public void getCheckUp(Animal patient) {
      // Instructions for method go here:
    }

    public void main(String[] args) {
      // Create a Vet object
      Vet catDoctor = newVet();
      // Create an Animal object
      Animal myCat = new Cat();
      // Send Animal object as a parameter for a Vet method:
      catDoctor.getCheckUp(myCat);
    }
  }

# Project- Language Families

*Error*
During the project i found that i could not compile one Class that called the subclass as the subclass was not yet compiled. However, i could not compile the subclass because it relied on the other class. 

Easy fix: 
Compile both at sametime- 
javac Language.java Mayan.java 

Other Option: 
Move the main method in to a seperate class- 
public class LanguageTest {
    public static void main(String[] args) {
        Language myLang = new Language("Spencer", 100, "United Kingdom", "subject-verb-object");
        myLang.getInfo();

        Mayan myMayan = new Mayan("Kiche", 1222223090);
        myMayan.getInfo();
    }
}